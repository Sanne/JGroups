
Design of FORK
==============

Author: Bela Ban
JIRA: https://issues.jboss.org/browse/JGRP-1613

The purpose of FORK is (1) to enable multiple light-weight channels (fork-channels) to piggyback messages on an existing
channel and (2) to add protocols to an existing channel that are only used by the light-weight channel.

This allows an application to reuse an existing channel (main-channel), e.g. the Infinispan channel inside the wildfly
application server, without having to configure and create an entirely new channel, which would be overkill
(duplicate resources) if only a few messages need to be sent every now and then. Yet the new fork channel will be
shielded from messages passing up and down the main channel.

This is all done without modifying the configuration of the main channel.

So if we have a main-channel, an application might want to require locking (PEER_LOCK), which is not defined in
the main-channel's configuration. This is done by creating a fork-stack in FORK, identified by a fork-id. All messages
with a header containing the fork-id will be sent up the stack with the same fork-id. Messages without a header will
be sent up the main stack by FORK. An overview is shown below:

   (main-ch)  (fork-ch7) (fork-ch8)
      ^           ^      (fork-ch9)
      |           |          ^
      |           |          |
      |      ----------- ---------
      |      |PEER_LOCK| |COUNTER|
   -------------------------------
   |FORK     |  id=1   | |  id=2 |
   -------------------------------
   |FRAG2|
   -------
   | GMS |
   -------
     ...


The main-channel is shown to the left. Messages sent down it will *not* have a header. We have 2 fork-stacks, one with
id=1 has a PEER_LOCK protocol and a fork-channel (fork-ch7). The other one (with id=2) has the COUNTER protocol on top
and 2 fork-channels: fork-ch8 and fork-ch9.


Multiplexing of messages
------------------------

When a message is sent down fork-ch9, the fork-channel will add a header with fork-ch-id=9 and fork-stack-id=2. On
the receiver's side, FORK looks at the header. If there is no header, it passes the message up the main-stack. If
there is a header, it grabs the fork-stack-id and finds the fork-stack matching it. If there is no matching
fork-stack, an exception will be thrown. Otherwise the message is passed up. In the example fork-stack-id is 2,
so the message is passed up to the COUNTER protocol. At the top of the fork-stack (which can btw have more than one
protocol), the fork protocol stack finds the fork-channel matching the fork-channel-id. If not found, an exception will
be thrown, else the message is passed to the corresponding fork-channel (fork-ch9).

There is a map between fork-channel-ids and fork-channels in the fork protocol stack which is used for the dispatching
of messages to the correct fork-channel.



Lifecycle of fork-channel
-------------------------

There are a few ways a fork-channel can be created.

(1) If the fork-stack (e.g. with id=2) already exists, a new fork-channel is created and inserted into the map of the
fork-channel's protocol stack. If a fork-channel with the given id already exists, we can either throw an exception or
return the existing channel (tbd).

(2) If the fork-stack with the given id doesn't exist, but FORK is present, then we can create the fork-stack and add it
to the map in FORK keyed by fork-stack-id. The we create or get the fork-channel as described in (1).

(3) If FORK doesn't exist, we can create it and insert it into the main protocol stack. To do this, we need to know
the location in the stack where the newly created FORK should be inserted, and possibly some configuration
fragment (ie. XML) needs to be passed to the create call. The rest is done as in (2).



Configuration of fork-stack
---------------------------



